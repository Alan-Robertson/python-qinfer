

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>qinfer.smc &mdash; QInfer 0.1a1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="QInfer 0.1a1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">QInfer 0.1a1 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for qinfer.smc</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">##</span>
<span class="c"># smc.py: Sequential Monte Carlo module</span>
<span class="c">##</span>
<span class="c"># Â© 2012 Chris Ferrie (csferrie@gmail.com) and</span>
<span class="c">#        Christopher E. Granade (cgranade@gmail.com)</span>
<span class="c">#</span>
<span class="c"># This file is a part of the Qinfer project.</span>
<span class="c"># Licensed under the AGPL version 3.</span>
<span class="c">##</span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU Affero General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU Affero General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU Affero General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">##</span>

<span class="c">## FEATURES ####################################################################</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="c">## ALL #########################################################################</span>

<span class="c"># We use __all__ to restrict what globals are visible to external modules.</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;SMCUpdater&#39;</span>
<span class="p">]</span>

<span class="c">## IMPORTS #####################################################################</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">abstract_model</span> <span class="kn">import</span> <span class="n">DifferentiableModel</span>
<span class="kn">from</span> <span class="nn">metrics</span> <span class="kn">import</span> <span class="n">rescaled_distance_mtx</span>

<span class="kn">from</span> <span class="nn">resamplers</span> <span class="kn">import</span> <span class="n">LiuWestResampler</span>

<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="kn">as</span> <span class="nn">la</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">outer_product</span><span class="p">,</span> <span class="n">mvee</span><span class="p">,</span> <span class="n">uniquify</span><span class="p">,</span> <span class="n">particle_meanfn</span><span class="p">,</span> \
        <span class="n">particle_covariance_mtx</span>
<span class="kn">from</span> <span class="nn">_exceptions</span> <span class="kn">import</span> <span class="n">ApproximationWarning</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>

<span class="c">## CLASSES #####################################################################</span>

<div class="viewcode-block" id="SMCUpdater"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater">[docs]</a><span class="k">class</span> <span class="nc">SMCUpdater</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Creates a new Sequential Monte carlo updater, using the algorithm of</span>
<span class="sd">    [GFWC12]_.</span>

<span class="sd">    :param qinfer.abstract_model.Model model: Model whose parameters are to be inferred.</span>
<span class="sd">    :param int n_particles: The number of particles to be used in the particle approximation.</span>
<span class="sd">    :param qinfer.distributions.Distribution prior: A representation of the prior distribution.</span>
<span class="sd">    :param callable resampler: Specifies the resampling algorithm to be used. See :ref:`resamplers`</span>
<span class="sd">        for more details.</span>
<span class="sd">    :param float resample_thresh: Specifies the threshold for :math:`N_{\text{ess}}` to decide when to resample.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">n_particles</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span>
            <span class="n">resample_a</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">resampler</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">resample_thresh</span><span class="o">=</span><span class="mf">0.5</span>
            <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_resample_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span> <span class="o">=</span> <span class="n">n_particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="n">prior</span>

        <span class="c">## RESAMPLER CONFIGURATION ##</span>
        <span class="c"># Backward compatibility with the old resample_a keyword argument,</span>
        <span class="c"># which assumed that the Liu and West resampler was being used.</span>
        <span class="k">if</span> <span class="n">resample_a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;The &#39;resample_a&#39; keyword argument is deprecated; use &#39;resampler=LiuWestResampler(a)&#39; instead.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">resampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Both a resample_a and an explicit resampler were provided; please provide only one.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span> <span class="o">=</span> <span class="n">LiuWestResampler</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">resample_a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">resampler</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span> <span class="o">=</span> <span class="n">LiuWestResampler</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span> <span class="o">=</span> <span class="n">resampler</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">resample_thresh</span> <span class="o">=</span> <span class="n">resample_thresh</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_record</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c">## PARTICLE INITIALIZATION ##</span>
        <span class="c"># Particles are stored using two arrays, particle_locations and</span>
        <span class="c"># particle_weights, such that:</span>
        <span class="c"># </span>
        <span class="c"># particle_locations[idx_particle, idx_modelparam] is the idx_modelparam</span>
        <span class="c">#     parameter of the particle idx_particle.</span>
        <span class="c"># particle_weights[idx_particle] is the weight of the particle</span>
        <span class="c">#     idx_particle.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_particles</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">n_modelparams</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_particles</span><span class="p">,))</span> <span class="o">/</span> <span class="n">n_particles</span>

        <span class="k">for</span> <span class="n">idx_particle</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_particles</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="p">[</span><span class="n">idx_particle</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">prior</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>

    <span class="c">## PROPERTIES ##############################################################</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="SMCUpdater.resample_count"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.resample_count">[docs]</a>    <span class="k">def</span> <span class="nf">resample_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of times that the updater has resampled the particle</span>
<span class="sd">        approximation.</span>
<span class="sd">        </span>
<span class="sd">        :rtype: `int`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># We wrap this in a property to prevent external resetting and to enable</span>
        <span class="c"># a docstring.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resample_count</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="SMCUpdater.n_ess"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.n_ess">[docs]</a>    <span class="k">def</span> <span class="nf">n_ess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates the effective sample size (ESS) of the current distribution</span>
<span class="sd">        over model parameters.</span>

<span class="sd">        :return float: The effective sample size, given by :math:`1/\sum_i w_i^2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="SMCUpdater.data_record"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.data_record">[docs]</a>    <span class="k">def</span> <span class="nf">data_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># TODO: return read-only view onto the data record.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_record</span>

    <span class="c">## PRIVATE METHODS #########################################################</span>
    </div>
    <span class="k">def</span> <span class="nf">_maybe_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the resample threshold and conditionally resamples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ess</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_thresh</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">()</span>
            <span class="k">pass</span>

    <span class="c">## UPDATE METHODS ##########################################################</span>

<div class="viewcode-block" id="SMCUpdater.hypothetical_update"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.hypothetical_update">[docs]</a>    <span class="k">def</span> <span class="nf">hypothetical_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outcomes</span><span class="p">,</span> <span class="n">expparams</span><span class="p">,</span> <span class="n">return_likelihood</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces the particle weights for the posterior of a hypothetical</span>
<span class="sd">        experiment.</span>

<span class="sd">        :param outcomes: Integer index of the outcome of the hypothetical</span>
<span class="sd">            experiment.</span>
<span class="sd">            TODO: Fix this to take an array-like of ints as well.</span>
<span class="sd">        :type outcomes: int or an ndarray of dtype int.</span>
<span class="sd">        :param expparams: TODO</span>

<span class="sd">        :type weights: ndarray, shape (n_outcomes, n_expparams, n_particles)</span>
<span class="sd">        :param weights: Weights assigned to each particle in the posterior</span>
<span class="sd">            distribution :math:`\Pr(\omega | d)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># It&#39;s &quot;hypothetical&quot;, don&#39;t want to overwrite old weights yet!</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span>

        <span class="c"># Check if we have a single outcome or an array. If we only have one</span>
        <span class="c"># outcome, wrap it in a one-index array.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">outcomes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">outcomes</span><span class="p">])</span>

        <span class="c"># update the weights sans normalization</span>
        <span class="c"># Rearrange so that likelihoods have shape (outcomes, experiments, models).</span>
        <span class="c"># This makes the multiplication with weights (shape (models,)) make sense,</span>
        <span class="c"># since NumPy broadcasting rules align on the right-most index.</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">likelihood</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">expparams</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">hyp_weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">*</span> <span class="n">L</span>
        
        <span class="c"># Sum up the weights to find the renormalization scale.</span>
        <span class="n">norm_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hyp_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        
        <span class="c"># As a special case, check whether any entries of the norm_scale</span>
        <span class="c"># are zero. If this happens, that implies that all of the weights are</span>
        <span class="c"># zero--- that is, that the hypothicized outcome was impossible.</span>
        <span class="c"># Conditioned on an impossible outcome, all of the weights should be</span>
        <span class="c"># zero. To allow this to happen without causing a NaN to propagate,</span>
        <span class="c"># we forcibly set the norm_scale to 1, so that the weights will</span>
        <span class="c"># all remain zero.</span>
        <span class="n">norm_scale</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">norm_scale</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c"># normalize</span>
        <span class="n">norm_weights</span> <span class="o">=</span> <span class="n">hyp_weights</span> <span class="o">/</span> <span class="n">norm_scale</span>
            <span class="c"># Note that newaxis is needed to align the two matrices.</span>
            <span class="c"># This introduces a length-1 axis for the particle number,</span>
            <span class="c"># so that the normalization is broadcast over all particles.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_likelihood</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">norm_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">norm_weights</span><span class="p">,</span> <span class="n">L</span>
</div>
<div class="viewcode-block" id="SMCUpdater.update"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outcome</span><span class="p">,</span> <span class="n">expparams</span><span class="p">,</span> <span class="n">check_for_resample</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an experiment and an outcome of that experiment, updates the</span>
<span class="sd">        posterior distribution to reflect knowledge of that experiment.</span>

<span class="sd">        After updating, resamples the posterior distribution if necessary.</span>

<span class="sd">        :param int outcome: Label for the outcome that was observed, as defined</span>
<span class="sd">            by the :class:`~qinfer.abstract_model.Model` instance under study.</span>
<span class="sd">        :param expparams: Parameters describing the experiment that was</span>
<span class="sd">            performed.</span>
<span class="sd">        :type expparams: :class:`~numpy.ndarray` of dtype given by the</span>
<span class="sd">            :attr:`~qinfer.abstract_model.Model.expparams_dtype` property</span>
<span class="sd">            of the underlying model</span>
<span class="sd">        :param bool check_for_resample: If :obj:`True`, after performing the</span>
<span class="sd">            update, the effective sample size condition will be checked and</span>
<span class="sd">            a resampling step may be performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># First, record the outcome.</span>
        <span class="c"># TODO: record the experiment as well.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_record</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outcome</span><span class="p">)</span>

        <span class="c"># Since hypothetical_update returns an array indexed by</span>
        <span class="c"># [outcome, experiment, particle], we need to strip off those two</span>
        <span class="c"># indices first.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypothetical_update</span><span class="p">(</span><span class="n">outcome</span><span class="p">,</span> <span class="n">expparams</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">check_for_resample</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_resample</span><span class="p">()</span>
            
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SMCUpdater.batch_update"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.batch_update">[docs]</a>    <span class="k">def</span> <span class="nf">batch_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outcomes</span><span class="p">,</span> <span class="n">expparams</span><span class="p">,</span> <span class="n">resample_interval</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Updates based on a batch of outcomes and experiments, rather than just</span>
<span class="sd">        one.</span>

<span class="sd">        :param numpy.ndarray outcomes: An array of outcomes of the experiments that</span>
<span class="sd">            were performed.</span>
<span class="sd">        :param numpy.ndarray expparams: Either a scalar or record single-index</span>
<span class="sd">            array of experiments that were performed.</span>
<span class="sd">        :param int resample_interval: Controls how often to check whether</span>
<span class="sd">            :math:`N_{\text{ess}}` falls below the resample threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO: write a faster implementation here using vectorized calls to</span>
        <span class="c">#       likelihood.</span>

        <span class="c"># Check that the number of outcomes and experiments is the same.</span>
        <span class="n">n_exps</span> <span class="o">=</span> <span class="n">outcomes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">expparams</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_exps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The number of outcomes and experiments must match.&quot;</span><span class="p">)</span>

        <span class="c"># Loop over experiments and update one at a time.</span>
        <span class="k">for</span> <span class="n">idx_exp</span><span class="p">,</span> <span class="p">(</span><span class="n">outcome</span><span class="p">,</span> <span class="n">experiment</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">izip</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">outcomes</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="n">expparams</span><span class="p">))):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">outcome</span><span class="p">,</span> <span class="n">experiment</span><span class="p">,</span> <span class="n">check_for_resample</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">idx_exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">resample_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_resample</span><span class="p">()</span>

    <span class="c">## RESAMPLING METHODS ######################################################</span>
</div>
<div class="viewcode-block" id="SMCUpdater.resample"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># TODO: add amended docstring.</span>

        <span class="c"># Record that we have performed a resampling step.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resample_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Find the new particle locations according to the chosen resampling</span>
        <span class="c"># algorithm.</span>
        <span class="c"># We pass the model so that the resampler can check for validity of</span>
        <span class="c"># newly placed particles.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">resampler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="p">)</span>

        <span class="c"># Reset the weights to uniform.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span><span class="p">)</span>


    <span class="c">## ESTIMATION METHODS ######################################################</span>
</div>
<div class="viewcode-block" id="SMCUpdater.est_mean"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.est_mean">[docs]</a>    <span class="k">def</span> <span class="nf">est_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an estimate of the posterior mean model, given by the</span>
<span class="sd">        expectation value over the current SMC approximation of the posterior</span>
<span class="sd">        model distribution.</span>
<span class="sd">        </span>
<span class="sd">        :rtype: :class:`numpy.ndarray`, shape ``(n_modelparams,)``.</span>
<span class="sd">        :returns: An array containing the an estimate of the mean model vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="c"># We need the particle index to be the rightmost index, so that</span>
            <span class="c"># the two arrays align on the particle index as opposed to the</span>
            <span class="c"># modelparam index.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
            <span class="c"># The argument now has shape (n_modelparams, n_particles), so that</span>
            <span class="c"># the sum should collapse the particle index, 1.</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
</div>
<div class="viewcode-block" id="SMCUpdater.est_covariance_mtx"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.est_covariance_mtx">[docs]</a>    <span class="k">def</span> <span class="nf">est_covariance_mtx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an estimate of the covariance of the current posterior model</span>
<span class="sd">        distribution, given by the covariance of the current SMC approximation.</span>
<span class="sd">        </span>
<span class="sd">        :rtype: :class:`numpy.ndarray`, shape</span>
<span class="sd">            ``(n_modelparams, n_modelparams)``.</span>
<span class="sd">        :returns: An array containing the estimated covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">particle_covariance_mtx</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SMCUpdater.bayes_risk"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.bayes_risk">[docs]</a>    <span class="k">def</span> <span class="nf">bayes_risk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expparams</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Bayes risk for a hypothetical experiment, assuming the</span>
<span class="sd">        quadratic loss function defined by the current model&#39;s scale matrix</span>
<span class="sd">        (see :attr:`qinfer.abstract_model.Simulatable.Q`).</span>
<span class="sd">        </span>
<span class="sd">        :param expparams: The experiment at which to compute the Bayes risk.</span>
<span class="sd">        :type expparams: :class:`~numpy.ndarray` of dtype given by the current</span>
<span class="sd">            model&#39;s :attr:`~qinfer.abstract_model.Simulatable.expparams_dtype` property,</span>
<span class="sd">            and of shape ``(1,)``</span>
<span class="sd">            </span>
<span class="sd">        :return float: The Bayes risk for the current posterior distribution</span>
<span class="sd">            of the hypothetical experiment ``expparams``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This subroutine computes the bayes risk for a hypothetical experiment</span>
        <span class="c"># defined by expparams.</span>

        <span class="c"># Assume expparams is a single experiment</span>

        <span class="c"># expparams =</span>
        <span class="c"># Q = np array(Nmodelparams), which contains the diagonal part of the</span>
        <span class="c">#     rescaling matrix.  Non-diagonal could also be considered, but</span>
        <span class="c">#     for the moment this is not implemented.</span>
        <span class="n">nout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_outcomes</span><span class="p">(</span><span class="n">expparams</span><span class="p">)</span> <span class="c"># This is a vector so this won&#39;t work</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypothetical_update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nout</span><span class="p">),</span> <span class="n">expparams</span><span class="p">,</span> <span class="n">return_likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="c"># Fix w.shape == (n_outcomes, n_particles).</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="c"># Fix L.shape == (n_outcomes, n_particles).</span>

        <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="c"># shape (n_mp, n_particles).</span>
        
        <span class="c"># In the following, we will use the subscript convention that</span>
        <span class="c"># &quot;o&quot; refers to an outcome, &quot;p&quot; to a particle, and</span>
        <span class="c"># &quot;i&quot; to a model parameter.</span>
        <span class="c"># Thus, mu[o,i] is the sum over all particles of w[o,p] * x[i,p].</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;op,ip&#39;</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
        
        <span class="n">var</span> <span class="o">=</span> <span class="p">(</span>
            <span class="c"># This sum is a reduction over the particle index and thus</span>
            <span class="c"># represents an expectation value over the diagonal of the</span>
            <span class="c"># outer product $x . x^T$.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;op,ip&#39;</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">xs</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c"># We finish by subracting from the above expectation value</span>
            <span class="c"># the diagonal of the outer product $mu . mu^T$.</span>
            <span class="o">-</span> <span class="n">mu</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


        <span class="n">rescale_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">Q</span> <span class="o">*</span> <span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># Q has shape (n_mp,), therefore rescale_var has shape (n_outcomes,).</span>
        <span class="n">tot_like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tot_like</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">rescale_var</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="SMCUpdater.est_entropy"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.est_entropy">[docs]</a>    <span class="k">def</span> <span class="nf">est_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nz_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nz_weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">nz_weights</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="SMCUpdater.est_kl_divergence"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.est_kl_divergence">[docs]</a>    <span class="k">def</span> <span class="nf">est_kl_divergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
        <span class="c"># TODO: document.</span>
        <span class="k">if</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">pdf</span>
        
        <span class="n">dist</span> <span class="o">=</span> <span class="n">rescaled_distance_mtx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        
        
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">est_entropy</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span> <span class="o">*</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">particle_weights</span> <span class="o">*</span> <span class="n">K</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="c"># Sum over the particles of ``other``.</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>  <span class="c"># Sum over the particles of ``self``.</span>
        <span class="p">)</span>
        </div>
<div class="viewcode-block" id="SMCUpdater.est_cluster_moments"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.est_cluster_moments">[docs]</a>    <span class="k">def</span> <span class="nf">est_cluster_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_opts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># TODO: document</span>
        
        <span class="k">if</span> <span class="n">cluster_opts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cluster_opts</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">cluster_label</span><span class="p">,</span> <span class="n">cluster_particles</span> <span class="ow">in</span> <span class="n">clustering</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">,</span>
                <span class="o">**</span><span class="n">cluster_opts</span>
            <span class="p">):</span>
            
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">[</span><span class="n">cluster_particles</span><span class="p">]</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="p">[</span><span class="n">cluster_particles</span><span class="p">]</span>
            <span class="k">yield</span> <span class="p">(</span>
                <span class="n">cluster_label</span><span class="p">,</span>
                <span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="c"># The zeroth moment is very useful here!</span>
                <span class="n">particle_meanfn</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">),</span>
                <span class="n">particle_covariance_mtx</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
            </div>
<div class="viewcode-block" id="SMCUpdater.est_cluster_covs"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.est_cluster_covs">[docs]</a>    <span class="k">def</span> <span class="nf">est_cluster_covs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_opts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># TODO: document</span>
        
        <span class="n">cluster_moments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_cluster_moments</span><span class="p">(</span><span class="n">cluster_opts</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">,</span> <span class="s">&#39;int&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;weight&#39;</span><span class="p">,</span> <span class="s">&#39;float64&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;mean&#39;</span><span class="p">,</span> <span class="s">&#39;{}float64&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_modelparams</span><span class="p">)),</span>
                <span class="p">(</span><span class="s">&#39;cov&#39;</span><span class="p">,</span> <span class="s">&#39;{0},{0}float64&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_modelparams</span><span class="p">)),</span>
            <span class="p">])</span>
            
        <span class="n">ws</span> <span class="o">=</span> <span class="n">cluster_moments</span><span class="p">[</span><span class="s">&#39;weight&#39;</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            
        <span class="n">within_cluster_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ws</span> <span class="o">*</span> <span class="n">cluster_moments</span><span class="p">[</span><span class="s">&#39;cov&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">between_cluster_var</span> <span class="o">=</span> <span class="n">particle_covariance_mtx</span><span class="p">(</span>
            <span class="c"># Treat the cluster means as a new very small particle cloud.</span>
            <span class="n">cluster_moments</span><span class="p">[</span><span class="s">&#39;weight&#39;</span><span class="p">],</span> <span class="n">cluster_moments</span><span class="p">[</span><span class="s">&#39;mean&#39;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">total_var</span> <span class="o">=</span> <span class="n">within_cluster_var</span> <span class="o">+</span> <span class="n">between_cluster_var</span>
        
        <span class="k">return</span> <span class="n">within_cluster_var</span><span class="p">,</span> <span class="n">between_cluster_var</span><span class="p">,</span> <span class="n">total_var</span>
        </div>
<div class="viewcode-block" id="SMCUpdater.est_cluster_metric"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.est_cluster_metric">[docs]</a>    <span class="k">def</span> <span class="nf">est_cluster_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_opts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># TODO: document</span>
        <span class="n">wcv</span><span class="p">,</span> <span class="n">bcv</span><span class="p">,</span> <span class="n">tv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">est_cluster_covs</span><span class="p">(</span><span class="n">cluster_opts</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wcv</span> <span class="o">/</span> <span class="n">tv</span>
        

    <span class="c">## REGION ESTIMATION METHODS ###############################################</span>
</div>
<div class="viewcode-block" id="SMCUpdater.est_credible_region"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.est_credible_region">[docs]</a>    <span class="k">def</span> <span class="nf">est_credible_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mf">0.95</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array containing particles inside a credible region of a</span>
<span class="sd">        given level, such that the described region has probability mass</span>
<span class="sd">        no less than the desired level.</span>
<span class="sd">        </span>
<span class="sd">        Particles in the returned region are selected by including the highest-</span>
<span class="sd">        weight particles first until the desired credibility level is reached.</span>
<span class="sd">        </span>
<span class="sd">        :rtype: :class:`numpy.ndarray`, shape ``(n_credible, n_modelparams)``,</span>
<span class="sd">            where ``n_credible`` is the number of particles in the credible</span>
<span class="sd">            region</span>
<span class="sd">        :returns: An array of particles inside the estimated credible region.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c"># Start by sorting the particles by weight.</span>
        <span class="c"># We do so by obtaining an array of indices `id_sort` such that</span>
        <span class="c"># `particle_weights[id_sort]` is in descending order.</span>
        <span class="n">id_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c"># Find the cummulative sum of the sorted weights.</span>
        <span class="n">cumsum_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">[</span><span class="n">id_sort</span><span class="p">])</span>
        
        <span class="c"># Find all the indices where the sum is less than level.</span>
        <span class="c"># We first find id_cred such that</span>
        <span class="c"># `all(cumsum_weights[id_cred] &lt;= level)`.</span>
        <span class="n">id_cred</span> <span class="o">=</span> <span class="n">cumsum_weights</span> <span class="o">&lt;=</span> <span class="n">level</span>
        <span class="c"># By construction, by adding the next particle to id_cred, it must be</span>
        <span class="c"># true that `cumsum_weights[id_cred] &gt;= level`, as required.</span>
        <span class="n">id_cred</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">id_cred</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="c"># We now return a slice onto the particle_locations by first permuting</span>
        <span class="c"># the particles according to the sort order, then by selecting the</span>
        <span class="c"># credible particles.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="p">[</span><span class="n">id_sort</span><span class="p">][</span><span class="n">id_cred</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="SMCUpdater.region_est_hull"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.region_est_hull">[docs]</a>    <span class="k">def</span> <span class="nf">region_est_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mf">0.95</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates a credible region over models by taking the convex hull of</span>
<span class="sd">        a credible subset of particles.</span>
<span class="sd">        </span>
<span class="sd">        :param float level: The desired crediblity level (see</span>
<span class="sd">            :meth:`SMCUpdater.est_credible_region`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: document return values.</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">est_credible_region</span><span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">)</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">convex_hull</span>
        
        <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ib</span><span class="p">,</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">hull</span><span class="p">:</span>
            <span class="n">faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ib</span><span class="p">,</span> <span class="n">ic</span><span class="p">]])</span>    

        <span class="n">vertices</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">uniquify</span><span class="p">(</span><span class="n">hull</span><span class="o">.</span><span class="n">flatten</span><span class="p">())]</span>
        
        <span class="k">return</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span>
</div>
<div class="viewcode-block" id="SMCUpdater.region_est_ellipsoid"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.region_est_ellipsoid">[docs]</a>    <span class="k">def</span> <span class="nf">region_est_ellipsoid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates a credible region over models by finding the minimum volume</span>
<span class="sd">        enclosing ellipse (MVEE) of a credible subset of particles.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        :param float level: The desired crediblity level (see</span>
<span class="sd">            :meth:`SMCUpdater.est_credible_region`).</span>
<span class="sd">        :param float tol: The allowed error tolerance in the MVEE optimization</span>
<span class="sd">            (see :meth:`~qinfer.utils.mvee`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: document return values.</span>
        <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">region_est_hull</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
                
        <span class="n">A</span><span class="p">,</span> <span class="n">centroid</span> <span class="o">=</span> <span class="n">mvee</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">centroid</span>
        
    <span class="c">## MISC METHODS ############################################################</span>
    </div>
<div class="viewcode-block" id="SMCUpdater.risk"><a class="viewcode-back" href="../../apiref/smc.html#qinfer.smc.SMCUpdater.risk">[docs]</a>    <span class="k">def</span> <span class="nf">risk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayes_risk</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x0</span><span class="p">,)],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">expparams_dtype</span><span class="p">))</span>
        
                </div></div>
<span class="k">class</span> <span class="nc">SMCUpdaterBCRB</span><span class="p">(</span><span class="n">SMCUpdater</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Subclass of :class:`SMCUpdater`, adding Bayesian Cramer-Rao bound</span>
<span class="sd">    functionality.</span>
<span class="sd">    </span>
<span class="sd">    Models considered by this class must be differentiable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">SMCUpdater</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">DifferentiableModel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Model must be differentiable.&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">current_bim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">outer_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="o">.</span><span class="n">grad_log_pdf</span><span class="p">(</span><span class="n">particle</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">particle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span>
            <span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span>
        
    <span class="k">def</span> <span class="nf">hypothetical_bim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expparams</span><span class="p">):</span>
        <span class="c"># E_{prior} E_{data | model, exp} [outer-product of grad-log-likelihood]</span>
        <span class="n">like_bim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_bim</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">idx_particle</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span><span class="p">):</span>
        
            <span class="n">modelparams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>

            <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span>
            
            <span class="k">for</span> <span class="n">outcome</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">n_outcomes</span><span class="p">(</span><span class="n">expparams</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]:</span>
                 
                <span class="n">grad</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">grad_log_likelihood</span><span class="p">(</span><span class="n">outcome</span><span class="p">,</span> <span class="n">modelparams</span><span class="p">,</span> <span class="n">expparams</span><span class="p">))</span> 
                <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">likelihood</span><span class="p">(</span><span class="n">outcome</span><span class="p">,</span> <span class="n">modelparams</span><span class="p">,</span> <span class="n">expparams</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">like_bim</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">grad</span> <span class="o">*</span> <span class="n">L</span>
                
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_bim</span> <span class="o">+</span> <span class="n">like_bim</span>
        
        
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outcome</span><span class="p">,</span> <span class="n">expparams</span><span class="p">):</span>
        <span class="c"># Before we update, we need to commit the new Bayesian information</span>
        <span class="c"># matrix corresponding to the measurement we just made.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_bim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypothetical_bim</span><span class="p">(</span><span class="n">expparams</span><span class="p">)</span>
        
        <span class="c"># We now can update as normal.</span>
        <span class="n">SMCUpdater</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outcome</span><span class="p">,</span> <span class="n">expparams</span><span class="p">)</span>
        

<span class="k">class</span> <span class="nc">SMCUpdaterABC</span><span class="p">(</span><span class="n">SMCUpdater</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Subclass of :class:`SMCUpdater`, adding approximate Bayesian computation</span>
<span class="sd">    functionality.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">n_particles</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span>
                 <span class="n">abc_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">abc_sim</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abc_tol</span> <span class="o">=</span> <span class="n">abc_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abc_sim</span> <span class="o">=</span> <span class="n">abc_sim</span>
        
        <span class="n">SMCUpdater</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">n_particles</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">hypothetical_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outcomes</span><span class="p">,</span> <span class="n">expparams</span><span class="p">):</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span><span class="p">)</span>

        <span class="c"># Check if we have a single outcome or an array. If we only have one</span>
        <span class="c"># outcome, wrap it in a one-index array.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outcomes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">outcomes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">outcomes</span><span class="p">])</span>
        
        <span class="c">#TODO: lots of assumptions have been made to ensure the following works</span>
        <span class="c"># 1 - this may only work for binary outcomes</span>
        <span class="c"># 2 - in any case, it assumes the outcome of an experiment is a single number</span>
        
        <span class="c"># first simulate abc_sim experiments</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">simulate_experiment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="p">,</span> <span class="n">expparams</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">abc_sim</span><span class="p">)</span>
        <span class="c"># re-weight the particle by multiplying by number of simulated </span>
        <span class="c"># that came within a tolerance of abc_tol of the actual outcome    </span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">outcomes</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">abc_sim</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abc_tol</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
        
        <span class="c"># normalize</span>
        <span class="k">return</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outcome</span><span class="p">,</span> <span class="n">expparams</span><span class="p">,</span> <span class="n">check_for_resample</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypothetical_update</span><span class="p">(</span><span class="n">outcome</span><span class="p">,</span> <span class="n">expparams</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_for_resample</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_resample</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">QInfer 0.1a1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Christopher Ferrie and Christopher Granade.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>